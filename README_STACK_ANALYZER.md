# Stack Usage Analyzer

A Python tool to analyze worst-case stack usage for FreeRTOS tasks in the DiveCAN HUD Firmware project.

## Overview

This script analyzes the build artifacts generated by the ARM GCC compiler to determine the worst-case stack usage for each FreeRTOS task. It parses:

- **`.su` files**: Stack usage information generated by `-fstack-usage` flag
- **`.callgraph` files**: Function call relationships generated by `-fdump-analyzer-callgraph` flag

The analyzer builds a complete call graph and traces through all possible execution paths to find the worst-case stack consumption for each task.

## Features

- ✅ Parses compiler-generated stack usage files
- ✅ Builds complete function call graphs
- ✅ Identifies FreeRTOS task entry points automatically
- ✅ Calculates worst-case stack usage including all callees
- ✅ Handles library functions (HAL, FreeRTOS, stdio) with realistic estimates
- ✅ Detects stack overflows and tight margins
- ✅ Shows detailed call paths for each task
- ✅ Compares against allocated stack sizes (from `common.h`)

## Requirements

- Python 3.6 or later
- A built project (`.su` and `.callgraph` files in `build/` directory)

## Usage

### Basic Usage

```bash
# Analyze all tasks using default build directory
python3 analyze_stack_usage.py

# or make it executable and run directly
chmod +x analyze_stack_usage.py
./analyze_stack_usage.py
```

### Advanced Usage

```bash
# Use custom build directory
python3 analyze_stack_usage.py -b path/to/build

# Analyze specific tasks only
python3 analyze_stack_usage.py -t TSCTask BlinkTask

# Verbose output
python3 analyze_stack_usage.py -v
```

### Command-Line Options

```
-b, --build-dir DIR   Build directory containing .su and .callgraph files (default: build)
-t, --tasks TASK...   Specific task names to analyze (default: all detected tasks)
-v, --verbose         Verbose output
-h, --help           Show help message
```

## Example Output

```
================================================================================
STACK USAGE ANALYSIS REPORT
================================================================================

Task Name                  Worst-Case (B)   Allocated (B)      Margin (B)
--------------------------------------------------------------------------------
AlertTask                             168            512            344 ✓ Generous
BlinkTask                             592           2048           1456 ✓ Generous
StartDefaultTask                      256            512            256
TSCTask                               208            512            304

TOTAL                                1224           3584           2360

Overall stack efficiency: 34.2% utilized

================================================================================
DETAILED CALL PATHS (Worst-Case)
================================================================================

BlinkTask: 592 bytes
----------------------------------------
BlinkTask: 128 bytes (cumulative: 128)
  processPPO2Data: 192 bytes (cumulative: 320)
    logNonFatalError: 64 bytes (cumulative: 384)
      writeToEEPROM: 128 bytes (cumulative: 512)
        HAL_FLASH_Program: 80 bytes (cumulative: 592)
```

## How It Works

### 1. Stack Usage File Parsing

The script reads `.su` files that contain per-function stack usage:

```
main.c:100:1:TSCTask    64    static
leds.c:30:1:setRGB      40    static
```

### 2. Call Graph Construction

It parses `.callgraph` files to understand which functions call which:

```
"BlinkTask/234" -> "processPPO2Data/567"
"processPPO2Data/567" -> "calculateAlarmState/234"
```

### 3. Worst-Case Path Analysis

For each task, the analyzer:
1. Starts at the task entry point
2. Recursively follows all function calls
3. Calculates cumulative stack usage along each path
4. Identifies the path with maximum stack consumption
5. Detects and warns about recursion

### 4. Library Function Handling

For library functions without `.su` data, the script uses conservative estimates:

| Function Type | Estimated Stack |
|--------------|----------------|
| `printf`     | 512 bytes      |
| `sprintf`    | 256 bytes      |
| `HAL_I2C_*`  | 96 bytes       |
| `HAL_UART_*` | 64 bytes       |
| `osDelay`    | 32 bytes       |
| Unknown      | 128 bytes      |

These estimates are based on typical ARM Cortex-M implementations and err on the conservative side.

## Interpreting Results

### Status Indicators

- **⚠️ OVERFLOW!**: Worst-case usage exceeds allocated stack size - **immediate action required**
- **⚠️ Tight**: Less than 128 bytes margin remaining - **review recommended**
- **✓ Generous**: More than 50% margin - likely safe but consider optimization

### Margin Recommendations

- **< 0 bytes**: Stack overflow risk - increase stack size
- **< 128 bytes**: Very tight - add more margin
- **128-512 bytes**: Reasonable margin for most tasks
- **> 512 bytes**: Good margin, stack size could potentially be reduced

### Important Notes

1. **These are static estimates**: Actual runtime stack usage may vary based on:
   - Compiler optimizations
   - Interrupt nesting
   - Dynamic stack frames (VLAs - should be avoided)

2. **Library estimates are conservative**: Actual library function stack usage may be lower

3. **Recursion is detected**: But can't be accurately measured - avoid recursion in embedded systems

4. **Indirect calls**: Function pointers and callbacks may not be captured in the call graph

## Integration with Development Workflow

### During Development

Run the analyzer after significant code changes:

```bash
make -j20 && python3 analyze_stack_usage.py
```

### In CI/CD Pipeline

Add to your CI pipeline to catch stack issues early:

```bash
# Build project
make -j20

# Analyze stack usage
python3 analyze_stack_usage.py || exit 1

# Fail if any task has negative margin
# (add custom checks as needed)
```

### Adjusting Stack Sizes

If a task shows overflow or tight margin:

1. Review the detailed call path to understand where stack is consumed
2. Consider refactoring to reduce stack usage:
   - Use smaller local variables
   - Move large buffers to heap or static storage
   - Reduce nesting depth
3. If necessary, increase stack size in `Core/Src/common.h`:
   ```c
   #define BLINK_STACK_SIZE 512  // Increase from 256
   ```

## Troubleshooting

### "No .su files found"

**Cause**: Project hasn't been built with `-fstack-usage` flag

**Solution**: Build the project with `make -j20` - the Makefile already includes this flag

### "No .callgraph files found"

**Cause**: Project hasn't been built with `-fdump-analyzer-callgraph` flag

**Solution**: Build the project with `make -j20` - the Makefile already includes this flag

### "No FreeRTOS tasks found"

**Cause**: Task functions don't match expected naming patterns

**Solution**: Tasks should be named with patterns like:
- `*Task` (e.g., `BlinkTask`, `TSCTask`)
- `*Thread` (e.g., `MainThread`)
- `vTask*` (FreeRTOS convention)
- `Start*Task` (e.g., `StartDefaultTask`)

### Incorrect Results

If results seem wrong:
1. Ensure project is fully rebuilt (`make clean && make -j20`)
2. Check that all source files are being compiled
3. Verify callgraph files are being generated
4. Run with `-v` flag for verbose debugging output

## Limitations

1. **Static analysis only**: Cannot account for runtime-dependent behavior
2. **Indirect calls**: Function pointers may not be captured in call graph
3. **Library functions**: Uses estimates rather than actual measurements
4. **Compiler variations**: Stack usage can vary between compiler versions
5. **Optimization levels**: Stack usage changes with optimization settings

## Contributing

To add support for additional library functions:

Edit the `LIBRARY_FUNCTION_ESTIMATES` dictionary in `analyze_stack_usage.py`:

```python
LIBRARY_FUNCTION_ESTIMATES = {
    'my_custom_function': 256,  # bytes
    # ... more functions
}
```

## References

- [GCC Stack Usage Documentation](https://gcc.gnu.org/onlinedocs/gcc/Instrumentation-Options.html)
- [FreeRTOS Stack Overflow Detection](https://www.freertos.org/Stacks-and-stack-overflow-checking.html)
- [ARM Cortex-M Stack Alignment](https://developer.arm.com/documentation/dui0552/a/the-cortex-m3-processor/exception-model/stack-alignment)

## License

This tool is part of the DiveCAN HUD Firmware project and follows the same license.
